\section{Einfluss der grundlegenden Indizes}\label{auswertung:basic_indizes}
%TODO
% Row with or without indices
% Column with or without indices
\begin{figure}[H]
    \centering
    \includegraphics[width=0.49\textwidth]{col_ind.png}
    \includegraphics[width=0.49\textwidth]{row_ind.png}
    \caption{Gesamtergebnis für Row- und Columnstore.}
	\label{fig:ind_overall}
\end{figure}

\subsection{Grundlegende Untersuchung für Columnstore}
\begin{table}[H]
\centering
    \begin{tabularx}{\textwidth}{lrrr}
        \toprule
        Merkmal             &   Col[ms]    &    Col Index[ms] & Abweichung[\%]\\
        \toprule
        Samples             &   250        &   250      &        \\
        \midrule    
        Median              &   373        &   286      & 23.3\%\\
        Average             &   376        &   289      & 23.1\%\\
        \bottomrule
    \end{tabularx}
\caption{Vergleich der Ergebnisse mit und ohne grundlegende Indizes für Columnstore.}
\label{tab:basic_index_col}
\end{table}

Durch hinzufügen der grundlegenden Indizes wurde der Benchmark
für Columstores sowohl im Schnitt als auch im Median schneller.
Im Schnitt wurde er 23,1\%, im Median um 23,3\% schneller.

Diese Ergebnisse sind interessant, da in der Regel davon ausgegangen wird, 
dass bei Columnstores kein großartiges Optimierungspotenzial durch Indizes vorhanden ist.
Um herauszufinden, warum trotzdem eine deutliche Verbesserung merkbar ist,
wird der Query-Execution Plan des Subqueries mit der deutlichsten Verbesserung
im folgenden untersucht.

\subsubsection{Untersuchung der Laufzeit für einzelne Query-Gruppen}

\begin{table}[H]
    \centering
    \begin{tabularx}{\linewidth}{crrr}
        \toprule
        Benchmarkgruppe & Col[ms]   & Col Index[ms] & Laufzeitreduzierung[ms|\%]\\
        \toprule
        Q1              & 104.7       & 68.5            & 36.2 | 34.5\%\\
        Q2              & 62.1        & 59.7            & 2.4 |  03.8\%\\
        Q3              & 96.2        & 54.8            & 41.4 | 40.8\%\\
        Q4              & 112.4       & 106.3           & 6.1 |  05.4\%\\
        \bottomrule
    \end{tabularx}
	\caption{Durchschnittslaufzeit für jede Benchmarkgruppe für Columnstore.}
\end{table}

Deutliche Verbesserungungen sind bei den Queries der Gruppen 1 und 3 festzustellen. Hier hat sich die Laufzeit um 35\% bzw. sogar 41\% reduziert. 
Die Queries dieser Gruppe werden im Detail untersucht, um geeignete Kandidaten für die Analyse des Execution-Plans zu finden.
Hier sind besonders bei Query 1.2 und 3.4 interessant, da diese die größte Verbesserung in ihrer Gruppe vorweisen können. 
Die Laufzeit wurde um 64\% für Query 1.1 und um mehr als 90\% für Query 3.4 reduziert. Woher diese Verbesserung kommen, soll im Folgenden durch die Analyse der Execution-Pläne von Query 1.1 und 3.4 geklärt werden.


\begin{table}[H]
    \centering
    \begin{tabularx}{\linewidth}{crrr}
        \toprule
        Benchmark           & Col[ms]       & Col Index[ms] & Laufzeitreduzierung[ms|\%]   \\
        \toprule
        Q1.1                & 36.1          & 36.4          & -0.3 | -0.8\%                \\
        Q1.2                & 47.8          & 16.8          & 31.0 | 64.8\%                 \\
        Q1.3                & 21.3          & 14.1          & 7.2 | 33.8\%                \\
        \midrule
        Q3.1                & 31.3          & 31.6          & -0.3 | -0.9\%                \\
        Q3.2                & 24.0          & 18.9          & 5.1 | 21.2\%                 \\
        Q3.3                & 21.3          & 2.1           & 19.2 | 90.1\%                \\
        Q3.4                & 20.5          & 1.6           & 18.9 | 92.1\%                \\
        \bottomrule
    \end{tabularx}
\caption{Durchschnittslaufzeit für Benchmarkgruppen 1 und 3 für Columnstore.}
\label{tab:q1_q3_col}
\end{table}

\subsubsection{Analyse von Query 3.4}
\textbf{Hinweis:} Die Ergebnisse in diesem Abschnitt basieren auf Ausführung auf einem PC mit einer Intel Xeon 1230 V3 CPU mit 16GB DDR3 RAM. Die VM hatte 4 Kerne und 8GB RAM zur Verfügung.

Bei der Analyse des Query-Execution Plans zeigt sich schnell,
woher die große Geschwindigkeitssteigerung kommt.
Query 3.4 bildet einen Join von Lineorder auf Customer,
Supplier und Dim\_Date. 
Dieser Join erfolgt jeweils über den Fremdschlüssel in Lineorder.
Ohne Indizes ist dieser Join ausschlaggebend für die Laufzeit des Querys.
Durch anlegen von Indizes auf alle Fremdschlüssel,
kann der Join deutlich schneller ausgeführt werden.
Den größten Vorteil hat hier der Index auf LO\_Suppkey.

Der Execution Plan ohne Indizes ist in \autoref{execution-plan:before-index}, sowie \autoref{exec:q3.4-col-no}
zu finden und der Execution Plan mit Indizes ist in \autoref{execution-plan:after-index},sowie \autoref{exec:q34-col-index} zu finden.

Query 3.1 im Vergleich nutzt zwar auch Fremdschlüssel, um einen Join zu bilden,
allerdings sind hier die nicht indizierten Felder \verb+S_Region+, \verb+D_Year+,
\verb+C_Nation+ und \verb+S_Nation+ in der Where- und der Group by-Klausel gelistet,
wodurch eine Geschwindigkeitsverbesserung nicht möglich ist.

Auch bei Columnstores scheinen sinnvoll angelegte Indizes also einen deutlichen Unterschied zu machen.

\subsubsection{Analyse von Query 1.2}
\textbf{Hinweis:} Die Ergebnisse in diesem Abschnitt basieren auf Ausführung auf einem PC mit einer Intel Xeon 1230 V3 CPU mit 16GB DDR3 RAM. Die VM hatte 4 Kerne und 8GB RAM zur Verfügung.
%https://archive.sap.com/discussions/thread/3429357





%http://saphanatutorial.com/sap-hana-modeling/
%https://archive.sap.com/discussions/thread/3340726

\setlength\intextsep{0pt}
\begin{wraptable}{r}{0.5\textwidth}
    \centering
    \begin{tabular}{cc}
        Col [ms]       & Col Index [ms]    \\
        \toprule
         16          & 6         \\   
    \end{tabular}
	\caption{Durchschnittslaufzeit für Query 1.2 bei Columnstore.}
    \label{tab:olap_q12}
\end{wraptable}

Bei Query 1.2 gibt es einen deutlichen Unterschied zwischen Index und kein Index. Hierbei kann der Index auf LO\_OrderDateKey für den JOIN genutzt werden und beschleunigt diesen somit.
Außerdem wird die Berechnung \textbf{sum(lo\_extendedprice*lo\_discount)} deutlich beschleunigt. Warum ist allerdings nicht klar, denn auf diese Felder wurde kein Index angelegt.


Schaut man sich genauer an, was an dieser Stelle passiert, so werden die gleichen Operationen auf die gleichen Datenmengen angewandt, allerdings sind die Operationen \textbf{mit} Index deutlich schneller.\footnote{Die letzte Zahl scheint jeweils die Laufzeit in ms zu sein, aber eine genaue Erklärung dieser Werte war leider nicht zu finden.}
\begin{lstlisting}[breaklines, caption=Ohne Index]
<executePop(
  <lockInputs(num=3,)=0.00>
    <calculateOnAttr(
      <calculateWithAggregation(rows=4301,inputs=2,outputs=1,)=8.04>
    rows=4301,outputs=1,)
  =8.15>
)=11.61>
\end{lstlisting}

\begin{lstlisting}[breaklines, caption=Mit Index]
<executePop(
  <lockInputs(num=3,)=0.00>
    <calculateOnAttr(
      <calculateWithAggregation(rows=4301,inputs=2,outputs=1,)=1.03>
    rows=4301,outputs=1,)
  =1.10>
)=1.18>
\end{lstlisting}

\iffalse
\setlength\intextsep{0pt}
%https://www.stechies.com/important-hints-related-sap-hana/
\begin{wraptable}{r}{0.5\textwidth}
    \begin{tabular}{ccc}
        \toprule
        Engine              & No Index [ms]   & Index [ms] \\
        \toprule
        OLAP                & 187        & 188            \\
        Colum               & 296        & 226            \\   
        \bottomrule
    \end{tabular}
	\caption{Durchschnitt der Gesamtlaufzeit mit und ohne OLAP-Engine bei Columnstore.}
    \label{tab:olap}
\end{wraptable}



Wie in Tabelle \ref{tab:olap} zu sehen, ist die OLAP-Engine insgesamt sowohl mit, als auch ohne Index deutlich schneller, als die Column-Engine. 

Durch den HINT \enquote{USE\_OLAP\_PLAN} kann die OLAP-Engine als bevorzugte Engine festgelegt werden. Führt man jeden der Querys mit diesem Hint durch, so liefert dies die folgenden Ergebnisse:

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.7]{olap_column_overall.png}
    \caption{Vergleich der Gesamtlaufzeit für Columnstore mit Indizes, testweise mit OLAP-Hint. n=100}
	\label{fig:olap_column_overall}
\end{figure}

Wie in Grafik \ref{fig:olap_column_overall} zu sehen, wird durch den OLAP-Hint eine deutliche Beschleunigung erzielt. Ob zusätzlich noch ein Index existiert hat jedoch wenig bis keinen Einfluss.

Bei genauerer Betrachtung der Laufzeit pro Benchmarkgruppe fällt besonders auf, dass die Querys der Gruppe 1 nicht von der OLAP-Engine profitieren, sondern sogar langsamer werden. 
Warum dies beim Durchführen des Benchmarks, aber nicht bei Analyse der Execution-Pläne der Fall ist, ist nicht klar.
\fi
\iffalse
\begin{figure}[H] 
    \centering{
    \includegraphics[scale=0.7]{olap_column_overall.png}
    \caption{Vergleich der Gesamtlaufzeit für Columnstore mit Indizes, testweise mit OLAP-Hint. n=100}\label{fig:olap_column_overall}}
\end{figure}

Die anderen Benchmarkgruppen werden durch den OLAP-Hint jedoch schneller, Gruppe 3 und 4 nur geringfügig, Gruppe 2 jedoch wird nahezu doppelt so schnell.
\begin{table}[H]
    \centering
    \begin{tabularx}{\textwidth}{lXrrrr}
    \toprule
	Wert        &	OLAP-Hint & Q1 	    &	Q2 	    &	Q3	    &	Q4 \\
    \toprule
    Average	    & Nein        &	23.5	&	72.5	&	60.4	&	69.9 \\
    Average     & Ja	      &	26.3	&	36.4	&	58.3	&	65.6 \\
    \midrule
    Median	    & Nein        &	23.4	&	72.1	&	60.2	&	69.3 \\
    Median	    & Ja          &	26.5	&	36.0	&	59.5	&	66.0 \\
    \bottomrule
    \end{tabularx}
	\caption{Laufzeit jeder Benchmarkgruppe für Columnstore mit Index, testweise mit OLAP-Hint. n=100}
    \label{tab:olap_bench}
\end{table}
%Hier dann Tabelle, wenn Benchmark fertig ist. 
\fi

\subsubsection{Fazit für Columnstores}
Auch Columnstores können durch geschickt gewählte Indizes deutlich beschleunigt werden. Durch Nutzung der OLAP-Engine können diese Beschleunigungen jedoch nochmals teils deutlich überboten werden. 
Es erscheint sinnvoller, sein Augenmerk darauf zu legen, dass Querys diese auch nutzen. Dies ist zwar über einen HINT möglich, davon wird in der Praxis jedoch abgeraten.
%https://archive.sap.com/discussions/thread/3277920

\subsection{Grundlegende Untersuchung für Rowstore}
Durch hinzufügen der grundlegenden Indizes wurde der Benchmark
für Rowstores sowohl im Schnitt als auch im Median schneller.
Im Schnitt wurde er 15,9\%, im Median um 15,9\% schneller.

Die Verbesserungen beim Rowstore fallen, zumindest relativ gesehen, deutlich geringer als beim Columnstore (23,1\% und 23,3\%) aus.

\begin{table}[H]
    \begin{tabularx}{\textwidth}{lrrr}
        \toprule
        Wert                & Row[ms] & Row Index[ms]   & Abweichung [\%]\\
        \toprule
        Samples             & 250      & 250            &   ---    \\
        \midrule
        Median              & 1794     & 1508           &  15.9\%     \\
        Average             & 1800     & 1513           &  15.9\%     \\
        \bottomrule
    \end{tabularx}
\caption{Vergleich der Ergebnisse mit und ohne grundlegende Indizes für Rowstore.}
\label{tab:basic_index_row}
\end{table}

Schaut man sich die Veränderung der Laufzeit für die einzelnen Querygruppen, so fällt auf, dass Gruppe 1 und 2 deutlich von den Indizes profitieren, Gruppe 3 so gut wie gar nicht und Gruppe 4 wurde sogar \textbf{deutlich} langsamer.
Um zu analysieren, woran diese deutlichen Verbesserungen/Verschlechterungen liegen, wird aus Gruppe 2 und 4 jeweils der Query mit der größten Änderung analysiert.

\begin{table}[H]
    \begin{tabularx}{\linewidth}{lrrrr}
        \toprule
                            &   q1          &   q2      &	q3      & q4          \\
        \toprule
        Row[ms]	            &	423	        &	352	    &	519	    & 507	      \\
        Row Index[ms]       &   170         &   90	    &   473	    & 780	      \\
        Verbesserung[ms]    &   253         &   120     &   46      & -273        \\
        Verbesserung[\%]    &   59,8\%      &   74,4\%  &   8,8\%   & -53,8\%     \\    
\bottomrule
\end{tabularx}
\caption{Durchschnittslaufzeit jeder Querygruppe. n=250}
\label{tab:basic_index_row}
\end{table}



\subsection{Analyse der Queries aus Gruppe 2}

Wie in \autoref{tab:q2_row} zu sehen, profitieren alle 3 Queries recht deutlich von den Indizes. 
Die deutlichste Änderung gibt es jedoch bei Query 2.3, welcher im folgenden im Detail untersucht werden soll.

\setlength\intextsep{0pt}
\begin{table}[H]
    \begin{tabularx}{\linewidth}{lrrr}
        \toprule
                        & q2.1  &	q2.2    &	q2.3 \\
        \toprule
        Row[ms]	        & 139	&	111	    &	102  \\
        Row Index[ms]   & 73	&   16	    &   4    \\
        Verbesserung[ms]  & 66    &   95      &   98   \\
        Verbesserung[\%]  & 47.4\%  &   85.5\%    &   96.0\% \\    
\bottomrule
\end{tabularx}
\caption{Laufzeiten der Queries aus Gruppe 2.}
\label{tab:q2_row}
\end{table}

Der Query Execution Plan für Query 2.3 ohne Index wird in \autoref{fig:q23_r}, der Plan für Query 2.3 mit Index in \autoref{fig:q23_r_I}, dargestellt.





\subsection{Analyse der Queries aus Gruppe 4}

Wie in \autoref{tab:q4_row} zu sehen, wird Query 4.3 sogar schneller durch die Indizes. 
Die beiden anderen Queries werden jedoch deutlich langsamer. Die deutlichste Änderung 
gibt es bei Query 4.1, welcher im folgenden im Detail untersucht werden soll.

\setlength\intextsep{0pt}
\begin{table}[H]
    \begin{tabularx}{\linewidth}{lrrr}
        \toprule
                        & q4.1      &	q4.2        &	q4.3       \\
        \toprule
        Row[ms]	        & 200	    &	175	        &	125        \\
        Row Index[ms]   & 421	    &   320	        &   78          \\
        Verbesserung[ms]  & -221      &   -145        &   47         \\
        Verbesserung[\%]  & -110\%    &   -82,8\%     &   37,6\%       \\    
\bottomrule
\end{tabularx}
\caption{Laufzeiten der Queries aus Gruppe 4.}
\label{tab:q4_row}
\end{table}

Der Query Execution Plan für Query 4.3 ohne Index wird in \autoref{fig:q43_r}, der Plan für Query 4.3 mit Index in \autoref{fig:q43_r_I}, dargestellt.



